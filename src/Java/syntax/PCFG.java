package nlg;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.security.KeyStore.Entry;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

import edu.stanford.nlp.ling.Label;
import edu.stanford.nlp.trees.Tree;

/**
 * A class that implements probabilistic context-free grammars.
 * 
 * @author Dylan Pollack

 *
 */
public class PCFG {
	
	// Hash Table that will track the number of occurrences of each rule
	private HashMap<String, HashMap<ArrayList<String>, Double>> counts;
	
	/**
	 * Create a new probabilistic context-free grammar from a text file
	 * containing parse trees. Also write a file that represents the grammar.
	 * 
	 * @param filename the text file from which to generate PCFG
	 * @param binarize whether or not to binarize the grammar
	 */
	public PCFG () {
		
		counts = new HashMap<String, HashMap<ArrayList<String>, Double>>();
		
	}
	
	/**
	 * Search through a parse tree and count the number of 
	 * occurrences of each rule.
	 * 
	 * @param tree the parse tree to search
	 */
	public void depthFirstSearch(Tree tree) {
		
		if (tree.isLeaf()) return;
		
		// lefthand symbol
		String lhs = tree.label().toString();
		
		// list of righthand symbols
		ArrayList<String> rhs = new ArrayList<String>();
		Tree[] children = tree.children();
		for (Tree child : children) {
			rhs.add(child.label().toString());
		}
		
		// check for terminal nodes
		if (tree.isPreTerminal()) {
			rhs.add(" " + rhs.remove(0)); // mark terminal symbol with a space
		}
		
		if (counts.containsKey(lhs)) {
			
			double count = counts.get(lhs).containsKey(rhs) ? counts.get(lhs).get(rhs) : 0.0;
			counts.get(lhs).put(rhs, count + 1);
			
		} else {
			
			counts.put(lhs, new HashMap<ArrayList<String>,Double>());
			counts.get(lhs).put(rhs, 1.0);
			
		}
	
		
		for (Tree child : children) {
			depthFirstSearch(child);
		}
		
		
	}
	
	/**
	 * Convert the count of each rule into a probability.
	 */
	public void calculateProbabilities() {
		
		for (String lhs : counts.keySet()) {
			
			double total = 0;
			for (double rhsValue : counts.get(lhs).values()) {
				total += rhsValue;
			}
			
			for (ArrayList<String> rhs : counts.get(lhs).keySet()) {
				
				double rhsValue = counts.get(lhs).get(rhs)/total;
				counts.get(lhs).put(rhs, rhsValue);
			}
		}
	}
	
	/**
	 * Walk through the PCFG to generate a sentence. Each time a rule 
	 * diverges, choose "randomly" based on the conditional probability 
	 * distribution.
	 * 
	 * @param lhs Root node
	 * @return A string generated by starting from the root node
	 */
	public String stepThrough(String lhs) {
		
		double p = Math.random();
		double current = 0;
		
		if (counts.containsKey(lhs)) {
			
			for (ArrayList<String> rhs : counts.get(lhs).keySet()) {
				
				current += counts.get(lhs).get(rhs);
				
				if (current > p) {
					
					if (isLexical(rhs)) return rhs.get(0);
					
					String sentence = "";
					for (String s : rhs) {
						sentence += stepThrough(s);
					}
					return sentence;
						
				}
			}
			
			System.out.println("Error: Probabilities do not sum to 1.");
			return "---";
			
		}
		
		System.out.println("Error: Input symbol " + lhs + " not found in grammar.");
		return "";
		
	}
	
	/**
	 * Write the PCFG to a text file.
	 * 
	 * @param filename Name of the file to write
	 * @throws IOException
	 */
	public void writeToFile(String filename) throws IOException {
		
		PrintWriter pw = new PrintWriter(new FileWriter(filename));
		 
		for (String lhs : counts.keySet()) {
			
			for (ArrayList<String> rhs : counts.get(lhs).keySet()) {
								
				boolean isLexical = isLexical(rhs);
								
				GrammarRule rule = new GrammarRule(lhs, rhs, isLexical);
				rule.setWeight(counts.get(lhs).get(rhs));
								
				pw.write(rule.toString() + "\n");
			
			}
		}
	 
		pw.close();
		
	}
	
	public static PCFG loadFromFile (String filename) throws IOException {
		
		PCFG pcfg = new PCFG();
		
		BufferedReader br = new BufferedReader(new FileReader(filename));
		String line = br.readLine();
		
		while (line != null) {
			
			GrammarRule rule = new GrammarRule(line);
			
			if (!rule.isLexical()) {
			
				String lhs = rule.getLhs(); // get lefthand side of rule

				ArrayList<String> rhs = rule.getRhs(); // get righthand side
				// if (rule.isLexical()) rhs.add(" " + rhs.remove(0)); // mark
				// lexical rules

				double weight = rule.getWeight(); // get probability

				if (pcfg.counts.containsKey(lhs)) {
					pcfg.counts.get(lhs).put(rhs, weight);
				}

				else {
					pcfg.counts.put(lhs,
							new HashMap<ArrayList<String>, Double>());
					pcfg.counts.get(lhs).put(rhs, weight);
				}
			}
			
			line = br.readLine();
		}
		
		br.close();
		
		return pcfg;
		
	}
	
	public void addRules (HashMap<String, HashMap<ArrayList<String>, Double>> rules) {
		
		for (String lhs : rules.keySet()) {
			
			if (counts.containsKey(lhs)) {
				
				for (ArrayList<String> rhs : rules.get(lhs).keySet()) {
					
					counts.get(lhs).put(rhs, rules.get(lhs).get(rhs));
					
				}
			}
			
			else {
				
				counts.put(lhs, rules.get(lhs));
				
			}
		}
		
	}
	
	/**
	 * Check for terminal nodes.
	 * @param rhs The right-hand side of a grammar rule
	 * @return Whether or not the rule is lexical
	 */
	private boolean isLexical (ArrayList<String> rhs) {
		
		return rhs.get(0).startsWith(" ");
		
	}
	
}
